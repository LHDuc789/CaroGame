# -*- coding: utf-8 -*-
"""monte_carlo_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1if7a3xxL1dAB1dV8RhDGo0xABfDqqg9a
"""

#----- 15/08/2023 -----
import tkinter as tk
from tkinter import ttk
#----- 15/08/2023 -----
import numpy as np
import pickle
import os
import copy
from collections import defaultdict
#----- 15/08/2023 -----
import time
#----- 15/08/2023 -----
from itertools import chain


class State:
    def __init__(self, p1, p2):
        self.board = np.zeros((BOARD_ROWS, BOARD_COLS))
        self.p1 = p1
        self.p2 = p2
        self.isEnd = False
        self.boardHash = None
        # init p1 plays first
        self.playerSymbol = 1
        self.penal = 1 if NUMBERTOWIN == 3 else 2


    def getHash(self):
        self.boardHash = str(self.board.reshape(BOARD_COLS * BOARD_ROWS))
        return self.boardHash

    def winner(self):
        # row
        for i in range(BOARD_ROWS):
            for j in range(BOARD_COLS - NUMBERTOWIN + 1):
                win_board = sum(self.board[i, j:j + NUMBERTOWIN])
                if win_board == NUMBERTOWIN:
                    self.isEnd = True
                    return 1
                if win_board == -NUMBERTOWIN:
                    self.isEnd = True
                    return -1

        # col
        for i in range(BOARD_COLS):
            for j in range(BOARD_ROWS - NUMBERTOWIN + 1):
                win_board = sum(self.board[j:j + NUMBERTOWIN, i])
                if win_board == NUMBERTOWIN:
                    self.isEnd = True
                    return 1
                if win_board == -NUMBERTOWIN:
                    self.isEnd = True
                    return -1

        # # diagonal
        for r in range(BOARD_ROWS):
            for c in range(BOARD_COLS):
                if r + NUMBERTOWIN - 1 < BOARD_ROWS and c + NUMBERTOWIN - 1 < BOARD_COLS:
                    ldiagRight = []
                    for i in range(NUMBERTOWIN):
                        ldiagRight.append((r + i, c + i))
                    # print(ldiagRight)
                    # Xét điểm
                    diag_sum1 = sum([self.board[dr[0]][dr[1]] for dr in ldiagRight])
                    if diag_sum1 == NUMBERTOWIN:
                        self.isEnd = True
                        return 1
                    if diag_sum1 == -NUMBERTOWIN:
                        self.isEnd = True
                        return -1

        for r in range(BOARD_ROWS):
            for c in range(BOARD_COLS):
                if r + NUMBERTOWIN - 1 < BOARD_ROWS and c - NUMBERTOWIN + 1 >= 0:
                    ldiagLeft = []
                    for i in range(NUMBERTOWIN):
                        ldiagLeft.append((r + i, c - i))
                    # print(ldiagLeft)
                    # Xét điểm
                    diag_sum2 = sum([self.board[dl[0]][dl[1]] for dl in ldiagLeft])
                    if diag_sum2 == NUMBERTOWIN:
                        self.isEnd = True
                        return 1
                    if diag_sum2 == -NUMBERTOWIN:
                        self.isEnd = True
                        return -1

        # tie
        # no available positions
        if len(self.availablePositions()) == 0:
            self.isEnd = True
            return 0
        # not end
        self.isEnd = False
        return None

    def availablePositions(self):
        positions = []
        for i in range(BOARD_ROWS):
            for j in range(BOARD_COLS):
                if self.board[i, j] == 0:
                    positions.append((i, j))  # need to be tuple
        return positions

    def updateState(self, position):
        self.board[position] = self.playerSymbol
        # switch to another player
        self.playerSymbol = -1 if self.playerSymbol == 1 else 1

    # only when game ends
   # only when game ends
    def get_reward(self, act):
        result = self.winner()
        if result == 1:
            return 1, -1
        elif result == -1:
            return -1, 1
        elif result == 0:
            return 0, 0
        else:
            #Thêm reward -1 nếu máy không chặn khi đối thủ được x-1 con liên tục
            num_check_1 = NUMBERTOWIN - self.penal
            num_check_2 = -NUMBERTOWIN + self.penal
            flag_2x = False
            flag_2o = False
            #row
            for i in range(BOARD_ROWS):
                for j in range(BOARD_COLS - NUMBERTOWIN + 1):
                    win_board = self.board[i, j:j + NUMBERTOWIN]
                    sum_win_board = sum(win_board)
                    #if NUMBERTOWIN == 5:
                    if sum_win_board == 2 and -1 not in win_board:
                        if act[0] == i and act[1] in range(j, j + NUMBERTOWIN) and self.board[act[0], act[1]] == 1:
                            flag_2x = True
                            #return 0.1, 0
                        if NUMBERTOWIN == 3:
                            return 0, -1
                    ##
                    elif sum_win_board >= num_check_1 and -1 not in win_board:
                        if act[0] == i and act[1] in range(j, j + NUMBERTOWIN) and self.board[act[0], act[1]] == 1:
                            if sum_win_board == 3:
                                return 0.5, -0.5
                            return 0.8, -0.8
                        if sum_win_board == 4:
                            return 0, -0.8
                    #if NUMBERTOWIN == 5:
                    elif sum_win_board == -2 and 1 not in win_board:
                        if act[0] == i and act[1] in range(j, j + NUMBERTOWIN) and self.board[act[0], act[1]] == -1:
                            flag_2o = True
                            #return 0, 0.1
                        if NUMBERTOWIN == 3:
                            return -1, 0
                    ##
                    elif sum_win_board <= num_check_2 and 1 not in win_board:
                        if act[0] == i and act[1] in range(j, j + NUMBERTOWIN) and self.board[act[0], act[1]] == -1:
                            if sum_win_board == -3:
                                return -0.5, 0.5
                            return -0.8, 0.8
                        if sum_win_board == -4:
                            return -0.8, 0
          #col
            for i in range(BOARD_COLS):
                for j in range(BOARD_ROWS - NUMBERTOWIN + 1):
                    win_board = self.board[j:j + NUMBERTOWIN, i]
                    sum_win_board = sum(win_board)
                    #if NUMBERTOWIN == 5:
                    if sum_win_board == 2 and -1 not in win_board:
                        if act[1] == i and act[0] in range(j, j + NUMBERTOWIN) and self.board[act[0], act[1]] == 1:
                            flag_2x = True
                        if NUMBERTOWIN == 3:
                            return 0, -1
                    ##
                    elif sum_win_board >= num_check_1 and -1 not in win_board:
                        if act[1] == i and act[0] in range(j, j + NUMBERTOWIN) and self.board[act[0], act[1]] == 1:
                            if sum_win_board == 3:
                                return 0.5, -0.5
                            return 0.8, -0.8
                        if sum_win_board == 4:
                            return 0, -0.8
                    #if NUMBERTOWIN == 5:
                    elif sum_win_board == -2 and 1 not in win_board:
                        if act[1] == i and act[0] in range(j, j + NUMBERTOWIN) and self.board[act[0], act[1]] == -1:
                            flag_2o = True
                        if NUMBERTOWIN == 3:
                            return -1, 0
                    ##
                    elif sum_win_board <= num_check_2 and 1 not in win_board:
                        if act[1] == i and act[0] in range(j, j + NUMBERTOWIN) and self.board[act[0], act[1]] == -1:
                            if sum_win_board == -3:
                                return -0.5, 0.5
                            return -0.8, 0.8
                        if sum_win_board == -4:
                            return -0.8, 0
          #diagonal
            for r in range(BOARD_ROWS):
                for c in range(BOARD_COLS):
                    if r + NUMBERTOWIN - 1 < BOARD_ROWS and c + NUMBERTOWIN - 1 < BOARD_COLS:
                        ldiagRight = []
                        for i in range(NUMBERTOWIN):
                            ldiagRight.append((r + i, c + i))
                        # print(ldiagRight)
                        # Xét điểm
                        win_board = [self.board[dr[0]][dr[1]] for dr in ldiagRight]
                        diag_sum1 = sum(win_board)
                        #if NUMBERTOWIN == 5:
                        if diag_sum1 == 2 and -1 not in win_board:
                            if act in ldiagRight and self.board[act[0], act[1]] == 1:
                                flag_2x = True
                            if NUMBERTOWIN == 3:
                                return 0, -1
                        ##
                        elif diag_sum1 >= num_check_1 and -1 not in win_board:
                            if act in ldiagRight and self.board[act[0], act[1]] == 1:
                                if diag_sum1 == 3:
                                    return 0.5, -0.5
                                return 0.8, -0.8
                            if diag_sum1 == 4:
                                return 0, -0.8
                        #if NUMBERTOWIN == 5:
                        elif diag_sum1 == -2 and 1 not in win_board:
                            if act in ldiagRight and self.board[act[0], act[1]] == -1:
                                flag_2o = True
                            if NUMBERTOWIN == 3:
                                return -1, 0
                        ##
                        elif diag_sum1 <= num_check_2 and 1 not in win_board:
                            if act in ldiagRight and self.board[act[0], act[1]] == -1:
                                if diag_sum1 == -3:
                                    return -0.5, 0.5
                                return -0.8, 0.8
                            if diag_sum1 == -4:
                                return -0.8, 0

            for r in range(BOARD_ROWS):
                for c in range(BOARD_COLS):
                    if r + NUMBERTOWIN - 1 < BOARD_ROWS and c - NUMBERTOWIN + 1 >= 0:
                        ldiagLeft = []
                        for i in range(NUMBERTOWIN):
                            ldiagLeft.append((r + i, c - i))
                        win_board = [self.board[dl[0]][dl[1]] for dl in ldiagLeft]
                        diag_sum2 = sum(win_board)
                        #if NUMBERTOWIN == 5:
                        if diag_sum2 == 2 and -1 not in win_board:
                            if act in ldiagLeft and self.board[act[0], act[1]] == 1:
                                flag_2x = True
                            if NUMBERTOWIN == 3:
                                return 0, -1
                        ##
                        elif diag_sum2 >= num_check_1 and -1 not in win_board:
                            if act in ldiagLeft and self.board[act[0], act[1]] == 1:
                                if diag_sum2 == 3:
                                    return 0.5, -0.5
                                return 0.8, -0.8
                            if diag_sum2 == 4:
                                return 0, -0.8
                        #if NUMBERTOWIN == 5:
                        elif diag_sum2 == -2 and 1 not in win_board:
                            if act in ldiagLeft and self.board[act[0], act[1]] == -1:
                                flag_2o = True
                            if NUMBERTOWIN == 3:
                                return -1, 0
                        ##
                        elif diag_sum2 <= num_check_2 and 1 not in win_board:
                            if act in ldiagLeft and self.board[act[0], act[1]] == -1:
                                if diag_sum2 == -3:
                                    return -0.5, 0.5
                                return -0.8, 0.8
                            if diag_sum2 == -4:
                                return -0.8, 0
            if flag_2x:
                return 0.1, 0
            elif flag_2o:
                return 0, 0.1
            return 0, 0
    # board reset
    def reset(self):
        self.board = np.zeros((BOARD_ROWS, BOARD_COLS))
        self.boardHash = None
        self.isEnd = False
        self.playerSymbol = 1

    def play(self, rounds=100):
        # -----15/08/2023-----
        popup = tk.Toplevel()
        tk.Label(popup, text="Model Being Trained", font=("Arial", 16)).grid(row=0,column=0)
        percent_label = tk.Label(popup, text="0%", font=("Arial", 16))
        percent_label.grid(row=1, column=0)

        progress = 0
        progress_var = tk.DoubleVar()
        progress_bar = ttk.Progressbar(popup, variable=progress_var, maximum=100, length = 500)
            
        progress_bar.grid(row=2, column=0)
        popup.pack_slaves()
        progress_step = float(100.0/rounds)
        popup.grab_set()
        for i in range(rounds):
            popup.update()
            progress += progress_step
            percent_label.config(text=str(int(progress)) + "%")
            progress_var.set(progress)
            while not self.isEnd:
                # Player 1
                state = self.getHash()
                p1_action = self.p1.chooseAction(self.availablePositions(), self.board)
                # take action and update board state
                self.updateState(p1_action)
                reward_1 = self.get_reward(p1_action)[0]
                self.p1.addState(state, p1_action, reward_1)
                # check board status if it is ended
                win = self.winner()
                if win is not None:
                    # ended with p1 either win or draw
                    reward_2 = self.get_reward(p1_action)[1]
                    self.p2.addState(self.getHash(), None, reward_2)
                    self.p2.feed_reward()
                    self.p1.feed_reward()
                    self.p1.reset()
                    self.p2.reset()
                    self.reset()
                    break

                else:
                    # Player 2
                    state_2 = self.getHash()
                    p2_action = self.p2.chooseAction(self.availablePositions(), self.board)
                    # take action and update board state
                    self.updateState(p2_action)
                    reward_2 = self.get_reward(p2_action)[1]
                    self.p2.addState(state_2, p2_action, reward_2)
                    win = self.winner()
                    if win is not None:
                        # ended with p2 either win or draw
                        reward_1 = self.get_reward(p2_action)[0]
                        self.p1.addState(self.getHash(), None, reward_1)
                        self.p1.feed_reward()
                        self.p2.feed_reward()
                        self.p1.reset()
                        self.p2.reset()
                        self.reset()
                        break
        # -----15/08/2023-----
        time.sleep(0.5)
        popup.grab_release()
        popup.destroy()
        # -----15/08/2023-----                

class Player:
    def __init__(self, name, exp_rate=0.01):
        self.name = name
        self.states = []  
        self.lr = 0.2
        self.exp_rate = exp_rate
        self.decay_gamma = 0.9
        self.states_value = {} 
        self.N = {}
        self.sum_value = {}
        for i in range(BOARD_ROWS):
            for j in range(BOARD_COLS):
                p = (i, j)
                if self.sum_value.get(p) is None:
                    self.sum_value[p] = defaultdict(int)
                if self.N.get(p) is None:
                    self.N[p] = defaultdict(int)
                if self.states_value.get(p) is None:
                    self.states_value[p] = defaultdict(int)

    @staticmethod
    def getHash(board):
        boardHash = str(board.reshape(BOARD_COLS * BOARD_ROWS))
        return boardHash

    # e-greedy
    def chooseAction(self, positions, current_board):
        global action
        randValue = np.random.random()
        if randValue > self.exp_rate:
            board = current_board.copy()
            curr_board = self.getHash(board)
            values = np.array([self.states_value[p][curr_board] for p in positions])
            ix_max = np.where(values == np.max(values))[0]
            if len(ix_max) > 1:
                ix_select = np.random.choice(ix_max, 1)[0]
            else:
                ix_select = ix_max[0]
            action = positions[ix_select]
        else:
            # take random action
            idx = np.random.choice(len(positions))
            action = positions[idx]

        return action

    def feed_reward(self):
        discounts = np.array([self.decay_gamma**i for i in range(len(self.states)+1)])
        states, actions, rewards = zip(*self.states)
        for idx in range(len(self.states)):
            s = states[idx]
            a = actions[idx]
            if a is not None:
                self.sum_value[a][s] += sum(rewards[idx:] * discounts[:-(1+idx)])
                self.N[a][s] += 1
                self.states_value[a][s] = self.sum_value[a][s]/self.N[a][s]


    # append a hash state
    def addState(self, state, act, reward):
        self.states.append((state, act, reward))


    def reset(self):
        self.states = []


def Tic_Tac_Toe(n, m, x):
    if x > m and x > n:
        print()
        print("Invalid x !!! Please Enter Again !!!")
        print()
        return

    global BOARD_ROWS
    global BOARD_COLS
    global NUMBERTOWIN

    BOARD_ROWS = n
    BOARD_COLS = m
    NUMBERTOWIN = x

    p1 = Player("p1")
    p2 = Player("p2")
    st = State(p1, p2)
    print("training...")
    st.play(10000)
    po1 = p1.states_value
    po2 = p2.states_value
    p = {}
    for k, v in chain(po1.items(), po2.items()):
        if p.get(k) is None:
            p[k] = defaultdict(int)
        for kv, vv in v.items():
            p[k][kv] = vv
    fw = open('Policies/policy_' + str(n) + '_' + str(m) + '_' + str(x) + '_mc', 'wb')
    pickle.dump(p, fw)
    fw.close()
